"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SelfHealingHelper = void 0;
const LocatorStore_1 = require("./LocatorStore");
const HealingStrategies_1 = require("./HealingStrategies");
const Logger_1 = require("./Logger");
class SelfHealingHelper {
    // @ts-ignore
    constructor(page, store) {
        this.page = page;
        this.store = store;
        this.store = new LocatorStore_1.LocatorStore();
    }
    async find(selector) {
        const getLocator = (sel) => sel.startsWith("/") || sel.startsWith("//")
            ? this.page.locator(`xpath=${sel}`)
            : this.page.locator(sel);
        const locator = getLocator(selector);
        const count = await locator.count();
        // =====================================================
        // Case 1: DOM structure still exists
        // =====================================================
        if (count > 0) {
            try {
                // Try original selector
                await locator.first().waitFor({ state: "visible", timeout: 2000 });
                // Enrich with NextGenHeal(AI) candidates using parent DOM context
                const handle = await locator.first().elementHandle();
                if (handle) {
                    const domSnippet = await handle.evaluate((el) => {
                        const parent = el.parentElement;
                        return parent ? parent.outerHTML : el.outerHTML;
                    });
                    let aiCandidates = await (0, HealingStrategies_1.generateLocatorCandidatesWithAI)(domSnippet, selector);
                    Logger_1.Logger.debug("[SELF-HEALING] Raw NextGenHeal(AI) candidates (element exists): " + aiCandidates.map(c => c.selector).join(", "));
                    // Validate + dedup
                    aiCandidates = await this.filterValidCandidates(aiCandidates);
                    if (aiCandidates.length > 0) {
                        this.store.save(selector, selector, aiCandidates, {
                            lastSeen: this.DateTime(new Date()),
                            aiGenerated: true,
                        });
                    }
                }
                return locator;
            }
            catch {
                //  Original failed → try stored candidates
                const entry = this.store.get(selector);
                if (entry && entry.candidates.length > 0) {
                    for (const cand of entry.candidates) {
                        try {
                            const candidateLocator = getLocator(cand.selector);
                            const matches = await candidateLocator.count();
                            if (matches === 0) {
                                Logger_1.Logger.warn(`[SELF-HEALING] Skipping hallucinated candidate: ${cand.selector}`);
                                continue;
                            }
                            if (matches > 1) {
                                Logger_1.Logger.warn(`[SELF-HEALING] Candidate ${cand.selector} matched ${matches} elements. Skipping generic candidate.`);
                                continue;
                            }
                            await candidateLocator.first().waitFor({ state: "visible", timeout: 1500 });
                            this.store.save(selector, cand.selector, entry.candidates, {
                                lastSeen: this.DateTime(new Date()),
                                healed: true,
                            });
                            Logger_1.Logger.info(`[SELF-HEALING] Candidate healed: ${cand.selector}`);
                            return candidateLocator;
                        }
                        catch {
                            Logger_1.Logger.warn(`[SELF-HEALING] Candidate failed: ${cand.selector}`);
                            continue;
                        }
                    }
                }
                throw new Error(`[SELF-HEALING] Could not heal selector (structure exists, candidates failed): ${selector}`);
            }
        }
        // =====================================================
        // Case 2: DOM structure changed (count === 0)
        // =====================================================
        Logger_1.Logger.warn(`[SELF-HEALING] No elements found for ${selector}. Regenerating from full DOM.`);
        try {
            // Use full page DOM so NextGenHeal(AI) sees replacements (<button> → <div>)
            const domSnippet = await this.page.content();
            let aiCandidates = await (0, HealingStrategies_1.generateLocatorCandidatesWithAI)(domSnippet, selector);
            Logger_1.Logger.debug("[SELF-HEALING] Raw NextGenHeal(AI) candidates (regeneration): " + aiCandidates.map(c => c.selector).join(", "));
            // Validate + dedup
            aiCandidates = await this.filterValidCandidates(aiCandidates);
            if (aiCandidates.length > 0) {
                for (const cand of aiCandidates) {
                    try {
                        const candidateLocator = getLocator(cand.selector);
                        const matches = await candidateLocator.count();
                        if (matches === 0) {
                            Logger_1.Logger.warn(`[SELF-HEALING] Skipping hallucinated regenerated candidate: ${cand.selector}`);
                            continue;
                        }
                        if (matches > 1) {
                            Logger_1.Logger.warn(`[SELF-HEALING] Regenerated candidate ${cand.selector} matched ${matches} elements. Skipping generic candidate.`);
                            continue;
                        }
                        await candidateLocator.first().waitFor({ state: "visible", timeout: 2000 });
                        this.store.save(selector, cand.selector, aiCandidates, {
                            regenerated: true,
                            lastSeen: this.DateTime(new Date()),
                        });
                        Logger_1.Logger.info(`[SELF-HEALING] Regenerated and healed using: ${cand.selector}`);
                        return candidateLocator;
                    }
                    catch {
                        Logger_1.Logger.warn(`[SELF-HEALING] Regenerated candidate failed: ${cand.selector}`);
                        continue;
                    }
                }
            }
        }
        catch (err) {
            Logger_1.Logger.error("[SELF-HEALING] NextGenHeal(AI) regeneration failed: " + err);
        }
        throw new Error(`[SELF-HEALING] Could not heal locator (DOM changed): ${selector}`);
    }
    // =====================================================
    // Helper: Validate & Deduplicate only (no re-scoring)
    // =====================================================
    async filterValidCandidates(candidates) {
        const validated = [];
        const getLocator = (sel) => sel.startsWith("/") || sel.startsWith("//")
            ? this.page.locator(`xpath=${sel}`)
            : this.page.locator(sel);
        for (const cand of candidates) {
            try {
                const candidateLocator = getLocator(cand.selector);
                const count = await candidateLocator.count();
                if (count > 0) {
                    validated.push(cand);
                }
                else {
                    Logger_1.Logger.warn(`[SELF-HEALING] Dropping hallucinated candidate (not found in DOM): ${cand.selector}`);
                }
            }
            catch {
                Logger_1.Logger.warn(`[SELF-HEALING] Dropping invalid selector syntax: ${cand.selector}`);
            }
        }
        // Deduplicate by selector string
        const unique = new Map();
        for (const cand of validated) {
            unique.set(cand.selector, cand);
        }
        return Array.from(unique.values());
    }
    // @ts-ignore
    DateTime(date) {
        const mm = String(date.getMonth() + 1).padStart(2, "0");
        const dd = String(date.getDate()).padStart(2, "0");
        const yyyy = date.getFullYear();
        const hh = String(date.getHours()).padStart(2, "0");
        const min = String(date.getMinutes()).padStart(2, "0");
        const ss = String(date.getSeconds()).padStart(2, "0");
        return `${mm}/${dd}/${yyyy} ${hh}:${min}:${ss}`;
    }
}
exports.SelfHealingHelper = SelfHealingHelper;
