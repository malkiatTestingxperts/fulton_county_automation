"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SelfHealingHelper = void 0;
const LocatorStore_1 = require("./LocatorStore");
const HealingStrategies_1 = require("./HealingStrategies");
const Logger_1 = require("./Logger");
// Simple string similarity (0â€“1)
function stringSimilarity(a, b) {
    if (!a || !b)
        return 0;
    a = a.toLowerCase();
    b = b.toLowerCase();
    if (a === b)
        return 1;
    let matches = 0;
    const len = Math.min(a.length, b.length);
    for (let i = 0; i < len; i++) {
        if (a[i] === b[i])
            matches++;
    }
    return matches / Math.max(a.length, b.length);
}
class SelfHealingHelper {
    constructor(page, storeFile = "healingStore.json", storeDir) {
        this.page = page;
        this.store = new LocatorStore_1.LocatorStore(storeFile, storeDir);
    }
    /**
     * Main entry point for finding elements with self-healing
     */
    async find(selector) {
        // 1. Try original selector directly
        const originalLoc = this.page.locator(selector);
        if (await originalLoc.count() > 0) {
            Logger_1.Logger.info(`Original locator still works: ${selector}`);
            const meta = await this.getElementMeta(selector);
            if (meta) {
                const candidates = await (0, HealingStrategies_1.generateLocatorCandidates)(this.page, selector);
                await this.store.saveRecord(this.page, selector, selector, candidates, meta);
            }
            return originalLoc;
        }
        // 2. JSON fallback
        Logger_1.Logger.info(`Fallback: checking JSON for '${selector}'`);
        const stored = this.store.getAll().find((r) => r.original === selector);
        if (stored) {
            // Try current meta from DOM (if element still partially findable)
            const currentMeta = await this.getElementMeta(selector);
            if (currentMeta && this.store.getRecord(selector, currentMeta)) {
                // âœ… Meta matched â†’ reuse JSON candidates
                Logger_1.Logger.info(`[Meta matched âœ…] Using JSON candidates for: ${selector}`);
                for (const candidate of stored.candidates) {
                    const loc = this.page.locator(candidate.selector);
                    if (await loc.count() === 1) {
                        const candidateText = await loc.first().innerText().catch(() => "");
                        const sim = stringSimilarity(stored.meta.text || "", candidateText);
                        const baseScore = (0, HealingStrategies_1.heuristicScore)(candidate, stored.meta);
                        const combinedScore = baseScore + sim * 100;
                        Logger_1.Logger.info(`[Recovered âœ…] '${selector}' â†’ '${candidate.selector}' (score=${combinedScore})`);
                        return loc;
                    }
                }
            }
            else {
                // âŒ Meta changed or element missing â†’ regenerate using stored meta
                Logger_1.Logger.info(`[Meta changed ðŸ”„] Refreshing with stored meta for '${selector}'`);
                return await this.refreshRecordWithStoredMeta(selector, stored.meta);
            }
        }
        // 3. Healing from scratch
        Logger_1.Logger.info(`Healing required for: ${selector}`);
        return await this.refreshRecord(selector);
    }
    /**
     * Refresh candidates from DOM using the same selector
     */
    async refreshRecord(selector, newMeta) {
        Logger_1.Logger.info(`[Refreshing ðŸ”„] Regenerating candidates for: ${selector}`);
        const candidates = await (0, HealingStrategies_1.generateLocatorCandidates)(this.page, selector);
        for (const candidate of candidates) {
            const loc = this.page.locator(candidate.selector);
            if (await loc.count() === 1) {
                Logger_1.Logger.info(`[Healed âœ…] '${selector}' â†’ '${candidate.selector}'`);
                const meta = newMeta || (await this.getElementMeta(candidate.selector));
                if (meta) {
                    await this.store.saveRecord(this.page, selector, candidate.selector, candidates, meta);
                }
                return loc;
            }
        }
        throw new Error(`[SELF-HEALING âŒ] Could not find locator: ${selector}`);
    }
    /**
     * Refresh candidates using stored metadata
     */
    async refreshRecordWithStoredMeta(selector, storedMeta) {
        Logger_1.Logger.info(`[Refreshing ðŸ”„] Using stored meta for: ${selector}`);
        // Build parent selector
        const parentSel = storedMeta.parent?.id
            ? `#${storedMeta.parent.id}`
            : storedMeta.parent?.class
                ? `.${storedMeta.parent.class.split(" ")[0]}`
                : storedMeta.parent?.tag || "";
        // Prefer stored tag, but fallback to scanning all children if tag changed
        let altSelector = parentSel ? `${parentSel} ${storedMeta.tag}` : storedMeta.tag;
        let candidates = await (0, HealingStrategies_1.generateLocatorCandidates)(this.page, altSelector);
        if (!candidates || candidates.length === 0) {
            Logger_1.Logger.info(`[Fallback ðŸ”] Tag mismatch â†’ scanning all children of ${parentSel}`);
            const childHandles = await this.page.$$(parentSel + " *");
            for (const handle of childHandles) {
                const meta = await this.page.evaluate((el) => {
                    return {
                        tag: el.tagName.toLowerCase(),
                        text: el.textContent?.trim() || "",
                        attributes: Object.fromEntries(Array.from(el.getAttributeNames()).map((n) => [n, el.getAttribute(n) || ""])),
                        ariaLabel: el.getAttribute("aria-label") || "",
                        role: el.getAttribute("role") || "",
                    };
                }, handle);
                if ((storedMeta.text && meta.text && meta.text.toLowerCase().includes(storedMeta.text.toLowerCase())) ||
                    (storedMeta.ariaLabel && meta.ariaLabel === storedMeta.ariaLabel) ||
                    (storedMeta.role && meta.role === storedMeta.role)) {
                    altSelector = `${parentSel} ${meta.tag}`;
                    Logger_1.Logger.info(`[Fallback ðŸ”] Found possible replacement tag â†’ ${altSelector}`);
                    candidates = await (0, HealingStrategies_1.generateLocatorCandidates)(this.page, altSelector);
                    if (candidates && candidates.length > 0)
                        break;
                }
            }
        }
        // Pick first working candidate
        for (const candidate of candidates) {
            const loc = this.page.locator(candidate.selector);
            if (await loc.count() === 1) {
                Logger_1.Logger.info(`[Healed âœ…] '${selector}' â†’ '${candidate.selector}'`);
                const meta = await this.getElementMeta(candidate.selector);
                if (meta) {
                    await this.store.saveRecord(this.page, selector, candidate.selector, candidates, meta);
                }
                return loc;
            }
        }
        throw new Error(`[SELF-HEALING âŒ] Could not find locator using stored meta: ${selector}`);
    }
    /**
     * Capture element metadata for store
     */
    async getElementMeta(selector) {
        const elementHandle = await this.page.$(selector);
        if (!elementHandle)
            return null;
        return await this.page.evaluate((el) => {
            const attrs = {};
            for (const attr of el.getAttributeNames()) {
                attrs[attr] = el.getAttribute(attr) || "";
            }
            const parent = el.parentElement
                ? {
                    tag: el.parentElement.tagName.toLowerCase(),
                    id: el.parentElement.getAttribute("id") || undefined,
                    class: el.parentElement.getAttribute("class") || undefined,
                }
                : undefined;
            return {
                tag: el.tagName.toLowerCase(),
                text: el.textContent?.trim() || "",
                attributes: attrs,
                ariaLabel: el.getAttribute("aria-label") || "",
                role: el.getAttribute("role") || "",
                parent,
            };
        }, elementHandle);
    }
}
exports.SelfHealingHelper = SelfHealingHelper;
